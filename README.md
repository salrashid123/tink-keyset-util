## Tink Keyset Key Utility 

Utility function to extract or _export_ the embedded AES, RSA, ECC or HMAC key inside a [tink-crypto](https://github.com/tink-crypto) cleartext or encrypted keyset.  

You can also use this library to _import_ an external key into a tink keyset.

This repo also also allows for a way to _remove the prefix_ added by Tink to most ciphertext data generated by Tink.

Using both these functions will allow you to encrypt or sign some data with Tink and use off the shelf libraries to decrypt/verify later.

Basically, this is a way to remove the extra bits tink uses to make off-the-shelf compatibility a bit less challenging.


- **Export Key**

For key extraction, consider the following `AESGCM` keyset:

```bash
$ cat keysets/aes_gcm_1.json | jq '.'
{
  "primaryKeyId": 1651423683,
  "key": [
    {
      "keyData": {
        "typeUrl": "type.googleapis.com/google.crypto.tink.AesGcmKey",
        "value": "GiCL0DVayMOEPOt/vw76hVAFNmOqFcxQ3RCBiX1u8yy5FA==",
        "keyMaterialType": "SYMMETRIC"
      },
      "status": "ENABLED",
      "keyId": 1651423683,
      "outputPrefixType": "TINK"
    }
  ]
}
```

The `value` isn't the raw  AESGCM Key but its actually the [AesGcmKey proto](https://github.com/tink-crypto/tink-go/blob/main/proto/aes_gcm.proto#L64).

This sample will decode the proto and show the raw encryption key which you can directly use with off the shelf `crypto/aes` library

```bash
$ go run aes_export/insecurekeyset/main.go --insecure-key-set keysets/aes_gcm_1.bin 
		Raw key: i9A1WsjDhDzrf78O+oVQBTZjqhXMUN0QgYl9bvMsuRQ=
```

---

This utility only supports both binary and json keysets.  For an example with json keysets, see `example/aes_export/insecurejsonkeyset` folder

---

- **Extract CipherText**

If you use TINK to encrypt any data, then the ciphertext can have various prefixes added in by Tink.  Which means even with the raw key, the ciphertext wont decrypt.  These prefixes are descried in [TINK wire format prefixes](https://developers.google.com/tink/wire-format)

This library will detect the output type declared in the keyset, then remove the prefix value if `outputPrefix=TINK` was set using the primary KEYID so you can decrypt easily.   

For an end-to-end example with AESGCM, see [example/aes_export/insecurekeyset/main.go](example/aes_export/insecurekeyset/main.go)

---

- **Import Key**

You can also use this library to embed an *external* `AES-GCM`, `HMAC`, `RSA` or `ECC` key *into* a Tink insecure or encrypted keyset.  In other words, if you have a raw aes gcm key, you can embed that into a TINK keyset.  

For example, if you already have an `AES-GCM` key, you can use this library to create a tink keyset with that key.  

see 

* `AES`: [example/aes_import/insecurekeyset/main.go](example/aes_import/insecurekeyset/main.go)
* `HMAC`: [example/hmac_import/main.go](example/hmac_import/main.go)
* `RSA`: [example/rsa_import/main.go](example/rsa_import/main.go)
* `ECC`: [example/ecc_import/main.go](example/ecc_import/main.go)

---

This repo is a generic implementation of 

* [Importing and extracting external keys for BigQuery AEAD Tink KeySets](https://github.com/salrashid123/bq_aead_key)

---

### Key export

The key types supported are:

* `ExportAesGcmKey()`

  Extract the raw AES-GCM key from the keyset.  You can use this key to decrypt/encrypt data using standard google AES library

* `ExportAesSivKey()`

   Extract the raw AES-SIV key from the keyset.  You can use this key to decrypt/encrypt data using standard google AES library

* `ExportAesCtrHmacAeadKey()`

   Extract the raw AES and HMAC key from the keyset.  Using off the shelf libraries requires reversing [this](https://developers.google.com/tink/streaming-aead/aes_ctr_hmac_streaming) process.

* `ExportRsaSsaPkcs1PrivateKey()`

   Extract the RSA Private key from the keyset as DER bytes.

* `ExportRsaSsaPkcs1PublicKey()`

   Extract the RSA Public key from the keyset as DER bytes.

* `ExportEcdsaPrivateKey()`

   Extract the ECC Private key from the keyset as DER bytes.

* `ExportEcdsaPublicKey()`
  
   Extract the ECC Public key from the keyset as DER bytes.

* `ExportHMACKey()`
  
   Extract the HMAC the keyset.

To process TINK encoded ciphertext or data

* `ExportCipherText()`

  Returns the ciphertext or signature without the TINK prefix values.

  You can use this output with off the shelf crypto libraries to decrypt or verify.

### Key Import

* `ImportSymmetricKey()`

  Supply the raw aes key, the keyID to use and the output prefix to apply for this keyset

  If an external KMS KEK is provided, the output will be an encryptedKeySet

* `ImportHMACKey()`

   Import an external HMAC key into a tink keyset

* `ImportPublicKey()`

  Import an external RSA or ECC Public Key into a keyset


* `ImportPrivateKey()`

   Import an external RSA or ECC Private Key into a keyset
   

see the [example/](example/) folder for details

---

>> this library is **NOT** supported by google

---

### Usage

For key extraction supply the keyset.


```golang
	// load the keyset
	keysetBytes, err := os.ReadFile(*insecureKeySetFile)

	ku, err := keysetutil.NewTinkKeySetUtil(ctx, &keysetutil.KeySetUtilConfig{
		KeySetBytes: keysetBytes,
	})

	// print the raw key
	rk, err := ku.ExportAesGcmKey(keysetHandle.KeysetInfo().PrimaryKeyId)
	log.Printf("Raw key: %s", base64.StdEncoding.EncodeToString(rk))
```

For prefix redaction, supply the ciphertext provided by a prior tink operation.

```golang

	// load the keyset
	keysetBytes, err := os.ReadFile(*insecureKeySetFile)
	keysetReader := keyset.NewBinaryReader(bytes.NewReader(keysetBytes))
	keysetHandle, err := insecurecleartextkeyset.Read(keysetReader)   
	a, err := aead.New(keysetHandle)

	// use tink to encrypt
	ec, err := a.Encrypt([]byte("foo"), []byte("some additional data"))   

	// initialize this library
	ku, err := keysetutil.NewTinkKeySetUtil(ctx, &keysetutil.KeySetUtilConfig{
		KeySetBytes: keysetBytes,
	})

	// get the raw key from the keyset
	rk, err := ku.ExportAesGcmKey(keysetHandle.KeysetInfo().PrimaryKeyId)
	log.Printf("Raw key: %s", base64.StdEncoding.EncodeToString(rk))

	// initialize aes cipher from this extracted key
	aesCipher, err := aes.NewCipher(rk)
	rawAES, err := cipher.NewGCM(aesCipher)

	// omit the ciphertext prefix
	ecca, err := ku.ExportCipherText(ec, keysetHandle.KeysetInfo().PrimaryKeyId)

	// decrypt the tinkencrypted data using the raw ciphertext and raw aes key
	plaintext, err := rawAES.Open(nil, ecca[:keysetutil.AESGCMIVSize], ecca[keysetutil.AESGCMIVSize:], []byte("some additional data"))
```


THe following uses [tinkey](https://github.com/tink-crypto/tink-tinkey) to create binary keysets and then extract out the embedded keys.

You can either use the existing keysets or generate your own using [tinkey](https://developers.google.com/tink/install-tinkey).  For encrypted keysets, you certainly need to generate your own keysets.

for reference also see

* [tink_samples](https://github.com/salrashid123/tink_samples)
* [TINK Go TPM extension](https://github.com/salrashid123/tink-go-tpm/)
* [golang-jwt for Tink Keys](https://github.com/salrashid123/tink-keyset-util)

### Insecure KeySet

- `AES256_GCM`

```bash
$ cd example

$ tinkey list-key-templates

## if you want to create new keysets to test with:
# $ tinkey create-keyset --key-template=AES256_GCM --out-format=binary --out=keysets/aes_gcm_1.bin
# $ tinkey convert-keyset --in-format=binary --in=keysets/aes_gcm_1.bin --out-format=json --out=keysets/aes_gcm_1.json

## this repo could some sample keysets...so to use existing keyset with this repo
# $ tinkey list-keyset --in-format=binary --in=keysets/aes_gcm_1.bin

$ go run aes_export/insecurekeyset/main.go --insecure-key-set keysets/aes_gcm_1.bin
``` 

- `AES256_GCM_RAW`

```bash
# $ tinkey create-keyset --key-template=AES256_GCM_RAW --out-format=binary --out=keysets/aes_gcm_raw.bin

$ go run aes_export/insecurekeyset/main.go --insecure-key-set keysets/aes_gcm_raw.bin
```

- `AES256_SIV`

```bash
# $ tinkey create-keyset --key-template=AES256_SIV --out-format=binary --out=keysets/aes_siv.bin

$ go run aes_siv/insecurekeyset/main.go --insecure-key-set keysets/aes_siv.bin 
```

- `AES256_CTR_HMAC_SHA256`

```bash
# $ tinkey create-keyset --key-template=AES256_CTR_HMAC_SHA256 --out-format=binary --out=keysets/aes_ctr_hmac_sha256.bin

$ go run aes_ctr/insecurekeyset/main.go --insecure-key-set keysets/aes_ctr_hmac_sha256.bin 
```

- `RSA_SSA_PKCS1_3072_SHA256_F4`

```bash
# $ tinkey create-keyset --key-template=RSA_SSA_PKCS1_3072_SHA256_F4 --out-format=binary --out=keysets/rsa_1_private.bin
# $ tinkey create-public-keyset --in-format=binary --in=keysets/rsa_1_private.bin --out-format=binary --out=keysets/rsa_1_public.bin

$ go run rsa_export/insecurekeyset/main.go --insecure-key-set keysets/rsa_1_private.bin 
$ go run rsa_export/insecurekeyset/main.go --insecure-key-set keysets/rsa_1_public.bin 
```

- `ECDSA_P256`

```bash
# $ tinkey create-keyset --key-template=ECDSA_P256 --out-format=binary --out=keysets/ecc_1_private.bin
# $ tinkey create-public-keyset --in=keysets/ecc_1_private.bin --in-format=binary --out-format=binary --out=keysets/ecc_1_public.bin

$ go run ecc_export/insecurekeyset/main.go --insecure-key-set keysets/ecc_1_private.bin 
$ go run ecc_export/insecurekeyset/main.go --insecure-key-set keysets/ecc_1_public.bin 
```

- `HMAC_SHA256_256BITTAG`

```bash
# $ tinkey create-keyset --key-template=HMAC_SHA256_256BITTAG --out-format=binary --out=keysets/hmac_bittag.bin

$ go run hmac_export/main.go --insecure-key-set keysets/hmac_bittag.bin
```

- `HMAC_SHA256_256BITTAG_RAW`

```bash
# $ tinkey create-keyset --key-template=HMAC_SHA256_256BITTAG_RAW --out-format=binary --out=keysets/hmac_bittag_raw.bin

$ go run hmac_export/main.go --insecure-key-set keysets/hmac_bittag_raw.bin
```

---

### Encrypted KeySet

To test encrypted keysets, you need to have access to a KMS and have to create new keysets from scratch (since they're KMS encrypted with your key)

```bash
$ export PROJECT_ID=`gcloud config get-value core/project`
$ gcloud kms keyrings create kr1 --location=global
$ gcloud kms keys create --keyring=kr1 --location=global --purpose=encryption  k1

$ gcloud auth application-default login

$ export MASTERKEY="gcp-kms://projects/$PROJECT_ID/locations/global/keyRings/kr1/cryptoKeys/k1"

# $ tinkey create-keyset --master-key-uri=$MASTERKEY --key-template=AES256_GCM --out-format=binary --out=keysets/aes_gcm_1_kms.bin

$ go run aes_export/encryptedkeyset/main.go --encrypted-key-set keysets/aes_gcm_1_kms.bin --master-key-uri=$MASTERKEY
```

---

### Importing existing AES Key

To import an external AES_GCM key is pretty simple:

The following will create an AES_GCM Tink Keyset with the specified key, keyid and output prefix.

The return value is JSON keyset byte which you can convert to a JSON or Binary keyset for persistence. 

(see `example/aes_import/insecurekeyset/main.go` for examples of other importable keytypes)

```golang
	keyValue := "9d17bL1kuWVfEfn9skFI7Caost/X/Qf1/Wafl14gyGQ="
	keyid := 4112199248

	// aes-gcm
	k := gcmpb.AesGcmKey{
		Version:  0,
		KeyValue: kval,
	}

	ek, err := keysetutil.CreateSymmetricKey(k, uint32(*keyid), tinkpb.OutputPrefixType_TINK, nil)
```

```log
$ go run aes_import/insecurekeyset/main.go 

 {
	"primaryKeyId": 4112199248,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.AesGcmKey",
				"value": "GiD13XtsvWS5ZV8R+f2yQUjsJqiy39f9B/X9Zp+XXiDIZA==",
				"keyMaterialType": "SYMMETRIC"
			},
			"status": "ENABLED",
			"keyId": 4112199248,
			"outputPrefixType": "TINK"
		}
	]
}
2024/04/25 22:49:51 Tink Decrypted: foo

```

- Encrypted KeySet

For an encrypted keyset, supply the kek aead:

```golang
	gcpClient, err := gcpkms.NewClientWithOptions(ctx, "gcp-kms://")
	kmsaead, err := gcpClient.GetAEAD(*kmsURI)

	ek, err := keysetutil.CreateSymmetricKey(k, uint32(*keyid), tinkpb.OutputPrefixType_TINK, kmsaead)
```

```bash
$ go run aes_import/encryptedkeyset/main.go --master-key-uri=$MASTERKEY


 {
	"encryptedKeyset": "CiQAhitNP4eOsQPhMlF5W9YX4xM3PFl9r/UrmRl3zeqhEFcG+UoSSwCFB1VVAs6MzdRyQmkQm8mLlwkvv0z4cCPozxOUkx85IYqx+mnfwABE4yA7e7gIjIdQdf9kuUvydrKC+mjeD7TpgL9wNSPePRTcOg==",
	"keysetInfo": {
		"primaryKeyId": 4112199248,
		"keyInfo": [
			{
				"typeUrl": "type.googleapis.com/google.crypto.tink.AesGcmKey",
				"status": "ENABLED",
				"keyId": 4112199248,
				"outputPrefixType": "TINK"
			}
		]
	}
}
```

### Importing existing HMAC Key

The following will create an HMAC Tink Keyset with the specified key, keyid and output prefix.

The return value is JSON keyset byte which you can convert to a JSON or Binary keyset for persistence.

We are using raw outputprefix so so that we can easily see the hmac value is what we expect

```golang
	key        = flag.String("key", "change this password to a secret", "raw key")
	keyid      = flag.Uint("keyid", 4112199248, "raw key")
	plaintText = flag.String("plaintText", "foo", "some data to mac")

	ek, err := keysetutil.CreateHMACKey([]byte(*key), uint32(*keyid), common_go_proto.HashType_SHA256, tinkpb.OutputPrefixType_RAW, nil)
```

```bash
$ go run hmac_import/main.go 

 {
	"primaryKeyId": 4112199248,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.HmacKey",
				"value": "EgQIAxAgGiBjaGFuZ2UgdGhpcyBwYXNzd29yZCB0byBhIHNlY3JldA==",
				"keyMaterialType": "SYMMETRIC"
			},
			"status": "ENABLED",
			"keyId": 4112199248,
			"outputPrefixType": "RAW"
		}
	]
}

HMAC: 7c50506d993b4a10e5ae6b33ca951bf2b8c8ac399e0a34026bb0ac469bea3de2
```

### Importing existing Asymmetric Keys

#### Import RSA Public PEM to Tink RsaSsaPkcs1PublicKey

The following will import an RSA Public Key into a Tink Keyset

Specifically, to compare end-to-end, we'll extract the rsa key from `keysets/rsa_1_public.bin` and then generate a JSON keyset from it again

First print the RSA Key using the export function:

```bash
$ go run rsa_export/insecurekeyset/main.go --insecure-key-set keysets/rsa_1_public.bin 
-----BEGIN RSA PUBLIC KEY-----
MIIBigKCAYEA1cbMiupc8ENdRvW3Sw6Bkalgk4nL1Da8dsKanhe5aBs/pitOcTaf
Iw49CCyqR7Ld6g2JezUNARk+i8jk5J0C6jGpNmZKqgQd6j/94VQpjiesYsIJiMcJ
jSsrbwxn1so/+8YE6BQ6uzzFZVh7s6bYFpjPsKYKVgxbJ516+gijbNt5IgIYMf6i
R8vNXWXpl/AVDvbk/51HFrgFV8OrkziIowYAILsgXd8b/NBzuwHjnD153FeJ8Dah
1uScDp2xfkQ97TNgnKqprjyhJqVkIBhrYkgyYrWmjwywNGdwfjqAo2j1CfiTm/I+
PF9wPovauyqUJG0zLQTirLZRuZYrcMYNDq+JndEXjv0uLuZVjQGFBUUkpDTwy56v
T6h1aoImOpoqYMGkE/S/pbLc1bv7vnepJfskoHIdinjhX5uIU7F7RXjBMEZANtz+
6nv6fk3eztbRpGnpcyQHCz8WF05fTVD8UQM15kFqVMaYPcaTcKBbmaeiJs6Hr9Hw
7hZB0q2rRpVrAgMBAAE=
-----END RSA PUBLIC KEY-----
```

The RSA key is saved to a file at `keysets/rsa_public.pem`

Now import the PEM file and print it as a keyset:

```bash
$ go run rsa_import/insecurekeyset/public/main.go -keyFile keysets/rsa_public.pem

{
	"primaryKeyId": 4198955199,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PublicKey",
				"value": "EgIIAxqBAwDVxsyK6lzwQ11G9bdLDoGRqWCTicvUNrx2wpqeF7loGz+mK05xNp8jDj0ILKpHst3qDYl7NQ0BGT6LyOTknQLqMak2ZkqqBB3qP/3hVCmOJ6xiwgmIxwmNKytvDGfWyj/7xgToFDq7PMVlWHuzptgWmM+wpgpWDFsnnXr6CKNs23kiAhgx/qJHy81dZemX8BUO9uT/nUcWuAVXw6uTOIijBgAguyBd3xv80HO7AeOcPXncV4nwNqHW5JwOnbF+RD3tM2CcqqmuPKEmpWQgGGtiSDJitaaPDLA0Z3B+OoCjaPUJ+JOb8j48X3A+i9q7KpQkbTMtBOKstlG5litwxg0Or4md0ReO/S4u5lWNAYUFRSSkNPDLnq9PqHVqgiY6mipgwaQT9L+lstzVu/u+d6kl+ySgch2KeOFfm4hTsXtFeMEwRkA23P7qe/p+Td7O1tGkaelzJAcLPxYXTl9NUPxRAzXmQWpUxpg9xpNwoFuZp6Imzoev0fDuFkHSratGlWsiAwEAAQ==",
				"keyMaterialType": "ASYMMETRIC_PUBLIC"
			},
			"status": "ENABLED",
			"keyId": 4198955199,
			"outputPrefixType": "TINK"
		}
	]
}
```

Now compare the keyset to what the tinkey prints out directly from `keysets/rsa_1_public.bin`.  Both JSON Keysets are the same

```bash
$ tinkey convert-keyset --in-format=binary --in=keysets/rsa_1_public.bin --out-format=json  | jq '.'
{
  "primaryKeyId": 4198955199,
  "key": [
    {
      "keyData": {
        "typeUrl": "type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PublicKey",
        "value": "EgIIAxqBAwDVxsyK6lzwQ11G9bdLDoGRqWCTicvUNrx2wpqeF7loGz+mK05xNp8jDj0ILKpHst3qDYl7NQ0BGT6LyOTknQLqMak2ZkqqBB3qP/3hVCmOJ6xiwgmIxwmNKytvDGfWyj/7xgToFDq7PMVlWHuzptgWmM+wpgpWDFsnnXr6CKNs23kiAhgx/qJHy81dZemX8BUO9uT/nUcWuAVXw6uTOIijBgAguyBd3xv80HO7AeOcPXncV4nwNqHW5JwOnbF+RD3tM2CcqqmuPKEmpWQgGGtiSDJitaaPDLA0Z3B+OoCjaPUJ+JOb8j48X3A+i9q7KpQkbTMtBOKstlG5litwxg0Or4md0ReO/S4u5lWNAYUFRSSkNPDLnq9PqHVqgiY6mipgwaQT9L+lstzVu/u+d6kl+ySgch2KeOFfm4hTsXtFeMEwRkA23P7qe/p+Td7O1tGkaelzJAcLPxYXTl9NUPxRAzXmQWpUxpg9xpNwoFuZp6Imzoev0fDuFkHSratGlWsiAwEAAQ==",
        "keyMaterialType": "ASYMMETRIC_PUBLIC"
      },
      "status": "ENABLED",
      "keyId": 4198955199,
      "outputPrefixType": "TINK"
    }
  ]
}
```

**WARNING** for some reason, the only way i got it to work was to prepend a single 0 byte to the public keys:

```golang
	k := &rsppb.RsaSsaPkcs1PublicKey{
		Version: 0,
		Params: &rsppb.RsaSsaPkcs1Params{
			HashType: common_go_proto.HashType_SHA256,
		},
		N: append([]byte{0}, rk.N.Bytes()...),   // <<<<<<<<
		E: big.NewInt(int64(rk.E)).Bytes(),
	}
```

Why? i have no idea and only figured it out by looking at the proto encoding...this is a TODO to understand this

#### Import RSA Private PEM to Tink RsaSsaPkcs1PublicKey

As an end-to-end, first print the RSA Private Key.  This key happens to be the one inside the sample here: `keysets/rsa_1_private.bin ` 

```bash
$ go run rsa_export/insecurekeyset/main.go --insecure-key-set keysets/rsa_1_private.bin 

-----BEGIN RSA PRIVATE KEY-----
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
-----END RSA PRIVATE KEY-----
```

Now import the RSA PEM format

```bash
$ go run rsa_import/insecurekeyset/private/main.go -keyFile keysets/rsa_private.pem 
{
	"primaryKeyId": 4198955199,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PrivateKey",
				"value": "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",
				"keyMaterialType": "ASYMMETRIC_PRIVATE"
			},
			"status": "ENABLED",
			"keyId": 4198955199,
			"outputPrefixType": "TINK"
		}
	]
}
```

which is the same output key:

```bash
tinkey convert-keyset --in-format=binary --in=keysets/rsa_1_private.bin --out-format=json  | jq '.'

{
  "primaryKeyId": 4198955199,
  "key": [
    {
      "keyData": {
        "typeUrl": "type.googleapis.com/google.crypto.tink.RsaSsaPkcs1PrivateKey",
        "value": "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",
        "keyMaterialType": "ASYMMETRIC_PRIVATE"
      },
      "status": "ENABLED",
      "keyId": 4198955199,
      "outputPrefixType": "TINK"
    }
  ]
}
```

#### Import ECC Public PEM to Tink EcdsaPublicKey

To import an ECC Public key into a TinkKeySet, first print out the key we're using.  For this end-to-end, we're using the key thats actually inside `keysets/ecc_1_public.bin`

```bash
$ go run ecc_export/insecurekeyset/main.go --insecure-key-set keysets/ecc_1_public.bin 

-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEeKFBtNDgzgr1cuLLtSJlDzmal39Y
BGN5LPIuQk1px5zw5JoHU98I9w9p6ABraP5QAGnNWBcC+ngxC/PcyazQdA==
-----END PUBLIC KEY-----

```

The ECC key is saved to a file at `keysets/ecc_public.pem`

Now import the PEM file and print it as a keyset:

```bash
$ go run ecc_import/insecurekeyset/public/main.go -keyFile keysets/ecc_public.pem

{
	"primaryKeyId": 1957864605,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.EcdsaPublicKey",
				"value": "EgYIAxACGAIaIHihQbTQ4M4K9XLiy7UiZQ85mpd/WARjeSzyLkJNacecIiEA8OSaB1PfCPcPaegAa2j+UABpzVgXAvp4MQvz3Mms0HQ=",
				"keyMaterialType": "ASYMMETRIC_PUBLIC"
			},
			"status": "ENABLED",
			"keyId": 1957864605,
			"outputPrefixType": "TINK"
		}
	]
}

```

Now compare the keyset to what the tinkey prints out directly from `keysets/ecc_1_public.bin`.  Both JSON Keysets are the same

```bash
$ tinkey convert-keyset --in-format=binary --in=keysets/ecc_1_public.bin --out-format=json  | jq '.'

{
  "primaryKeyId": 1957864605,
  "key": [
    {
      "keyData": {
        "typeUrl": "type.googleapis.com/google.crypto.tink.EcdsaPublicKey",
        "value": "EgYIAxACGAIaIHihQbTQ4M4K9XLiy7UiZQ85mpd/WARjeSzyLkJNacecIiEA8OSaB1PfCPcPaegAa2j+UABpzVgXAvp4MQvz3Mms0HQ=",
        "keyMaterialType": "ASYMMETRIC_PUBLIC"
      },
      "status": "ENABLED",
      "keyId": 1957864605,
      "outputPrefixType": "TINK"
    }
  ]
}
```

**WARNING** for some reason, the only way i got it to work was to prepend a single 0 byte to the public keys:

```golang
	k := &ecdsapb.EcdsaPublicKey{
		Version: 0,
		Params: &ecdsapb.EcdsaParams{
			HashType: common_go_proto.HashType_SHA256,
			Curve:    common_go_proto.EllipticCurveType_NIST_P256,
			Encoding: ecdsapb.EcdsaSignatureEncoding_DER,
		},
		X: ecdsaPub.X.Bytes(),
		Y: append([]byte{0}, ecdsaPub.Y.Bytes()...),  // <<<<<<<<<<<<
	}
```

Why? i have no idea and only figured it out by looking at the proto encoding...this is a TODO to understand this


#### Import ECC Private PEM to Tink EcdsaPrivateKey

To import the private key, we'll again use the PEM format from the sample keyset we have `keysets/ecc_1_private.bin ` 

```bash
$  go run ecc_export/insecurekeyset/main.go --insecure-key-set keysets/ecc_1_private.bin 

-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIEXRWDDPHTUsOa6FxX2/EzdOIRjQtpLX3L69GuLZxxc7oAoGCCqGSM49
AwEHoUQDQgAEI+vmq6jr5qUfMBF98xqVuulDb76hDRjM2HlESvqk5ALXj4Vv19PX
Q2ucbNKLJvQWdlqQJZNO5XdqTEwu1551Ug==
-----END EC PRIVATE KEY-----
```

Now read the PEM and create the keyset

```bash
$ go run ecc_import/insecurekeyset/private/main.go -keyFile keysets/ecc_private.pem

{
	"primaryKeyId": 1957864605,
	"key": [
		{
			"keyData": {
				"typeUrl": "type.googleapis.com/google.crypto.tink.EcdsaPrivateKey",
				"value": "Ek0SBggDEAIYAhogeKFBtNDgzgr1cuLLtSJlDzmal39YBGN5LPIuQk1px5wiIQDw5JoHU98I9w9p6ABraP5QAGnNWBcC+ngxC/PcyazQdBogRdFYMM8dNSw5roXFfb8TN04hGNC2ktfcvr0a4tnHFzs=",
				"keyMaterialType": "ASYMMETRIC_PRIVATE"
			},
			"status": "ENABLED",
			"keyId": 1957864605,
			"outputPrefixType": "TINK"
		}
	]
}
```

Notice the keyset is the same as what we're printing directly.

```bash
$ tinkey convert-keyset --in-format=binary --in=keysets/ecc_1_private.bin --out-format=json  | jq '.'
{
  "primaryKeyId": 1957864605,
  "key": [
    {
      "keyData": {
        "typeUrl": "type.googleapis.com/google.crypto.tink.EcdsaPrivateKey",
        "value": "Ek0SBggDEAIYAhogeKFBtNDgzgr1cuLLtSJlDzmal39YBGN5LPIuQk1px5wiIQDw5JoHU98I9w9p6ABraP5QAGnNWBcC+ngxC/PcyazQdBogRdFYMM8dNSw5roXFfb8TN04hGNC2ktfcvr0a4tnHFzs=",
        "keyMaterialType": "ASYMMETRIC_PRIVATE"
      },
      "status": "ENABLED",
      "keyId": 1957864605,
      "outputPrefixType": "TINK"
    }
  ]
}
```